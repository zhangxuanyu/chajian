哈哈哈哈哈哈哈啊哈哈哈啊哈123
12131323123是
4564564654654
企鹅去委屈委屈委屈委屈we区委区为轻微请问请问	请问 

1. art-template 的使用
	-> 模板引擎的本质
		简化成一个用于显示打招呼的字符串
		'你好, 某某某'
		var name = '张三';

		var msg = '你好, ' + name + '!';
		缺点: 编写的代码不够明朗.

		var msgTpl = '你好, {{name}}!';
		var msg = msgTpl.replace( /\{\{.+\}\}/, name );
		缺点: 如果需要大量的数据替换, 我们需要熟练的使用正则表达式. 
		而且有大量的 replace 方法.

		var o = {
			name: 'jim',
			age: 19,
			gender: '男'
		};
		var msgTpl = '你好, 我叫 <%= name %>, 我的性别是: <%= gender %>, 我的年龄是: <%= age %>';

		var r = /<%=(.+?)%>/g;

		var res = msgTpl.replace( r, function ( _, propName ) {
			return o[ propName.trim() ] || '';
		});

		使用 art-template. 是别人专门为我们一般的用户封装的用于模板引擎渲染的 js 库.
		1> 不用自己写正则, 按照它的规则挖坑.
		2> 不用自己写 replace, 按照它给的 api 来调用即可.

		就是为了格式化我们想要的数据. 同时支持模板编写格式, 
		利用填充数据的办法来提供更多的功能.

		所以模板引擎的本质是利用提供好的 模板字符串, 和 替换对象 来实现模板的渲染.
		已达到想要的结构. 其核心还是在处理字符.



	-> art-template
		-> 前端的大部分 js 库都可以在 github 中找到
		-> 基本使用步骤
			1> 引入 js 文件( template-web.js )
			2> 写模板: 
				将模板写在 script 标签
				为 script 标签添加属性: type="text/template"
				还要给 script 标签添加一个 id. 以备后面所使用.
			3> 使用 template 函数
				语法:
					template( templateId: string, data: object ): string
			4> 使用 innerHTML 将渲染好的 html 格式的 字符串加入到页面中
		-> 挖坑的办法
			-> 原声语法
				<% 语法逻辑 %>
				<%= 表达式求值 %>
			-> 简写语法
				{{ ... }}
		-> 练习: 给定一个对象
			var data = [
				{ name: 'jim1', age: 19, gender: '男' },
				{ name: 'jim2', age: 9, gender: '女' },
				{ name: 'jim3', age: 29, gender: '男' },
				{ name: 'jim4', age: 39, gender: '女' },
				{ name: 'jim5', age: 49, gender: '男' },
				{ name: 'jim6', age: 59, gender: '女' }
			];
			使用 table 表格的方式将其展示出来.

	-> 简洁语法
		-> 使用 {{}}
		-> 如果要求一个变量的值, 直接写成: {{ 变量名 }}
		-> 注意, 直接插值不能使用 name

		-> 逻辑判断使用 
			{{ if 表达式 }} ... {{ /if }}
			{{ if 表达式 }} ... {{ else }} ... {{ /if }}

		-> 循环操作
			{{ each 数组 }} ... {{ /each }}
			在 循环中有两个默认的名字 $index, $value


2. 前端模块化
	-> 所谓的 模块化 就是说将代码 按照特定逻辑组合到一起. 进行编码和使用.
	-> 相关概念
		模块( module ): 在计算机中将一个可以替换的部分称为一个模块.
		模块化就是功能级别的复用.
		组件( component ): 组件是一个能够独立完成特定功能的一个具体的模块.
	-> 一般高级编程语言原生自带模块化的功能. 但是 js 没有.
		js 最早设计的时候就是给不会编程的 ui 设计人员做简单页面交互.
		node 平台诞生. js 在脱离了 浏览器后 需要为他设计一套完成的 api, 诞生 CommonJS
		最新的 js 开始诞生模块的概念了. 在 node 平台中原生 支持 模块化.
		可以使用 require 函数来加载模块. 在 node 中所有模块资源需要先下载. 即模块在本地

		在 浏览器中 无法实现, 因为 浏览器中 所有的资源来源于网络. 因此有人提出先下载资源,
		在加载模块. 因此引入了 异步加载的概念. 也就有 AMD 的模型. 即异步定义模块的模型. 
		其代表就是 require.js.

		在 中国有一个 叫 玉伯 提出 CMD 的概念. 开发了 sea.js 来实现模块化.


		Commonjs   nodejs加载规则 文件都存在本地（服务器） 不需要下载


		AMD  require.js    多了下载过程 
		CMD  sea.js





3. require.js 的使用
	-> 下载: http://requirejs.cn 或 http://requirejs.org
	-> 如何使用模块
		-> 模块化开发与非模块化开发的异同
			1) 非模块化开发
				1> 直接将 js 写到页面中( 优点: 结构明晰; 缺点: 复用问题, js 库的依赖 )
				2> 使用 js 文件编写, 使用 script 标签引入( 优点: 复用; 缺点: 依赖 )
			2) 模块化开发
				一般按照功能进行分类, 将一类特定的功能定义成一个模块( 一个 js 文件 )
				在页面中加载 该模块.
				优点: 
				1> 关注点集中, 将重点放在业务逻辑中. 更少的考虑依赖关系.
				2> 逻辑更加清晰, 因为按照功能划分模块.
				3> 划分过于细的时候, 数据共享不会受到影响.
		-> 通过代码来诠释
			模块化快速开始
			1> 引入 js 
			2> 定义模块
				define(function () {
					// 我们的模块的代码
				})
			3> 加载模块
				require( [ '模块名字' ] )
				注意: 模块的名字默认就是 定义模块的 文件名( 没有后缀 )

			任务: 在页面中创建 一个 div, 给他增加样式
			使用模块化还有一个问题: 
				越简单的代码使用模块化越复杂. 
				越复杂的代码使用模块化越简单.

4. requirejs 的具体使用
	-> 定义模块的语法
		语法:
			define( '模块名', [ 依赖的模块列表 ], function ( 依赖项列表 ) {
				// 定义的细节
			});
		说明:
		1> 第一个参数, 用于描述该模块的名字. 如果提供了该参数, 
			就表示当前模块为命名模块( named module ). 由于使用命名模块会比
			较麻烦, 后面详细说明其使用. 不提供该参数的为 匿名模块.
		2> 第二个参数用于描述当前模块需要使用的其他模块名.
			例如需要使用 jquery 的时候, 可以写成
				define( [ 'jquery文件名' ], function ( ... ) { ... } )
			如果要使用 jquery 和 template 那么可以定义为
				define( [ 'jquery', 'template' ], function ( ... ) { ... } )	
		3> 第三个参数是具体的模块定义. 但是如果依赖了其他模块, 
			这个函数的参数需要接收模块的返回结果.
			例如: 需要使用 jq
				define( [ 'jquery' ], function ( jquery ) {
					// 在当前函数中使用 jq 
					jquery
				} )
			再例如, 如果我们需要同时使用 jquery 和 template
				define( [ 'jquery', 'template' ], function ( $, template ) {
					// 在代码中就可以直接使用 $ 和 template 了
				} );
	->  js 代码的分类
		1> 为了实现特定的功能来执行相关的代码
		2> 定义一些工具( 对象, 函数, 常量 等 ), 以供其他的模块来使用.
		注意: 
			如果是第一种功能, 定义模块的时候, 代码写在回调函数中即可.
			但是如果是第二种情况, 就不太好了. 因为代码写在函数中,
			因此需要返回一些东西以供使用.
		如果是需要定义一个工具集, 那么我们的模块就需要将能够被使用的工具返回出去.

	-> 加载模块的语法
		语法: 
			require( [ '要加载的模块名' ], function ( ... ) { ... } )
		说明: 
			如果考虑, 加载模块后执行一个很短小的代码, 不需要考虑模块化, 
			那么直接将代码写到回调函数中即可.

	-> 模块路径
		我们在使用模块的时候, 使用模块的名字.
		1> 带有 ./, ../, / 等这样路径名的形式
		2> 只有一个文件名的形式

		首先使用的是路径名, 那么 就会路径的描述来找寻文件
		默认的路径搜索方式
		1> 使用一般的 require 来加载模块, 那么我们的默认路径就是当前 html 所在路径
		2> 使用 script 加载模块, 默认就是模块的路径为搜索路径
			在使用 script 引入 require.js 文件的时候, 可以提供一个 data-main
			自定义属性, 来说明 默认的加载的 模块.
		3> 使用 配置, 配置 baseUrl 那么修改默认的搜索路径
			配置步骤
			1) 引入 require.js 文件
			2) 调用 require.config() 方法来实现配置
			3) 使用 baseUrl 来配置搜索路径
			4) 凡是引入了 baseUrl, 我们在写 模块名的时候 都是在 baseUrl 所描述的路径中查找
	-> 配置短路径名
		使用短名字代替长名字. 语法:
		在配置中加上一个 paths 属性
			paths: {
				短名字: 长名字
			}
	-> 命名模块的使用方法
		使用命名模块的方法有两种
		1> 使得文件的名字与命名模块的名字一样, 而且文件必须在当前( 少用 )
		2> 配置短名字的时候短名字必须与模块中定义的名字相同( 推荐 )

	-> 非模块
		1> 一个自己封装的库, 它需要返回一个全局对象我们才可以使用
			可以使用配置来解决
			注意需要明确这个 库 返回的这个东西 的 名字
			在配置中添加代码
			 shim {
			 	模块名: {
			 		exports: '返回的名字'
			 	}
			 }

		2> 插件, 本身不需要返回任何数据, 但是依赖于某些代码
			如果插件式代码没有定义依赖, 那么我们需要手动的添加依赖
			 shim {
			 	模块名: {
			 		deps: [ '依赖的模块' ]
			 	}
			 }